/*! For license information please see d1b09459.0890193a.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[628],{2525:function(e){var n=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;function r(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var n={},t=0;t<10;t++)n["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(n).map((function(e){return n[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(r){return!1}}()?Object.assign:function(e,o){for(var i,l,s=r(e),c=1;c<arguments.length;c++){for(var u in i=Object(arguments[c]))t.call(i,u)&&(s[u]=i[u]);if(n){l=n(i);for(var p=0;p<l.length;p++)a.call(i,l[p])&&(s[l[p]]=i[l[p]])}}return s}},1535:function(e,n,t){var a=t(2525),r="function"==typeof Symbol&&Symbol.for,o=r?Symbol.for("react.element"):60103,i=r?Symbol.for("react.portal"):60106,l=r?Symbol.for("react.fragment"):60107,s=r?Symbol.for("react.strict_mode"):60108,c=r?Symbol.for("react.profiler"):60114,u=r?Symbol.for("react.provider"):60109,p=r?Symbol.for("react.context"):60110,h=r?Symbol.for("react.forward_ref"):60112,f=r?Symbol.for("react.suspense"):60113,d=r?Symbol.for("react.suspense_list"):60120,m=r?Symbol.for("react.memo"):60115,k=r?Symbol.for("react.lazy"):60116;r&&Symbol.for("react.fundamental"),r&&Symbol.for("react.responder"),r&&Symbol.for("react.scope");var y="function"==typeof Symbol&&Symbol.iterator;function g(e){for(var n=e.message,t="https://reactjs.org/docs/error-decoder.html?invariant="+n,a=1;a<arguments.length;a++)t+="&args[]="+encodeURIComponent(arguments[a]);return e.message="Minified React error #"+n+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",e}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},w={};function v(e,n,t){this.props=e,this.context=n,this.refs=w,this.updater=t||b}function C(){}function N(e,n,t){this.props=e,this.context=n,this.refs=w,this.updater=t||b}v.prototype.isReactComponent={},v.prototype.setState=function(e,n){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw g(Error(85));this.updater.enqueueSetState(this,e,n,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},C.prototype=v.prototype;var S=N.prototype=new C;S.constructor=N,a(S,v.prototype),S.isPureReactComponent=!0;var x={current:null},E={suspense:null},O={current:null},j=Object.prototype.hasOwnProperty,R={key:!0,ref:!0,__self:!0,__source:!0};function q(e,n,t){var a,r={},i=null,l=null;if(null!=n)for(a in void 0!==n.ref&&(l=n.ref),void 0!==n.key&&(i=""+n.key),n)j.call(n,a)&&!R.hasOwnProperty(a)&&(r[a]=n[a]);var s=arguments.length-2;if(1===s)r.children=t;else if(1<s){for(var c=Array(s),u=0;u<s;u++)c[u]=arguments[u+2];r.children=c}if(e&&e.defaultProps)for(a in s=e.defaultProps)void 0===r[a]&&(r[a]=s[a]);return{$$typeof:o,type:e,key:i,ref:l,props:r,_owner:O.current}}function T(e){return"object"==typeof e&&null!==e&&e.$$typeof===o}var P=/\/+/g,_=[];function U(e,n,t,a){if(_.length){var r=_.pop();return r.result=e,r.keyPrefix=n,r.func=t,r.context=a,r.count=0,r}return{result:e,keyPrefix:n,func:t,context:a,count:0}}function I(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>_.length&&_.push(e)}function $(e,n,t,a){var r=typeof e;"undefined"!==r&&"boolean"!==r||(e=null);var l=!1;if(null===e)l=!0;else switch(r){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case o:case i:l=!0}}if(l)return t(a,e,""===n?"."+A(e,0):n),1;if(l=0,n=""===n?".":n+":",Array.isArray(e))for(var s=0;s<e.length;s++){var c=n+A(r=e[s],s);l+=$(r,c,t,a)}else if(null===e||"object"!=typeof e?c=null:c="function"==typeof(c=y&&e[y]||e["@@iterator"])?c:null,"function"==typeof c)for(e=c.call(e),s=0;!(r=e.next()).done;)l+=$(r=r.value,c=n+A(r,s++),t,a);else if("object"===r)throw t=""+e,g(Error(31),"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t,"");return l}function D(e,n,t){return null==e?0:$(e,"",n,t)}function A(e,n){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,(function(e){return n[e]}))}(e.key):n.toString(36)}function H(e,n){e.func.call(e.context,n,e.count++)}function W(e,n,t){var a=e.result,r=e.keyPrefix;e=e.func.call(e.context,n,e.count++),Array.isArray(e)?L(e,a,t,(function(e){return e})):null!=e&&(T(e)&&(e=function(e,n){return{$$typeof:o,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}}(e,r+(!e.key||n&&n.key===e.key?"":(""+e.key).replace(P,"$&/")+"/")+t)),a.push(e))}function L(e,n,t,a,r){var o="";null!=t&&(o=(""+t).replace(P,"$&/")+"/"),D(e,W,n=U(n,o,a,r)),I(n)}function M(){var e=x.current;if(null===e)throw g(Error(321));return e}var Q={Children:{map:function(e,n,t){if(null==e)return e;var a=[];return L(e,a,null,n,t),a},forEach:function(e,n,t){if(null==e)return e;D(e,H,n=U(null,null,n,t)),I(n)},count:function(e){return D(e,(function(){return null}),null)},toArray:function(e){var n=[];return L(e,n,null,(function(e){return e})),n},only:function(e){if(!T(e))throw g(Error(143));return e}},createRef:function(){return{current:null}},Component:v,PureComponent:N,createContext:function(e,n){return void 0===n&&(n=null),(e={$$typeof:p,_calculateChangedBits:n,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:u,_context:e},e.Consumer=e},forwardRef:function(e){return{$$typeof:h,render:e}},lazy:function(e){return{$$typeof:k,_ctor:e,_status:-1,_result:null}},memo:function(e,n){return{$$typeof:m,type:e,compare:void 0===n?null:n}},useCallback:function(e,n){return M().useCallback(e,n)},useContext:function(e,n){return M().useContext(e,n)},useEffect:function(e,n){return M().useEffect(e,n)},useImperativeHandle:function(e,n,t){return M().useImperativeHandle(e,n,t)},useDebugValue:function(){},useLayoutEffect:function(e,n){return M().useLayoutEffect(e,n)},useMemo:function(e,n){return M().useMemo(e,n)},useReducer:function(e,n,t){return M().useReducer(e,n,t)},useRef:function(e){return M().useRef(e)},useState:function(e){return M().useState(e)},Fragment:l,Profiler:c,StrictMode:s,Suspense:f,unstable_SuspenseList:d,createElement:q,cloneElement:function(e,n,t){if(null==e)throw g(Error(267),e);var r=a({},e.props),i=e.key,l=e.ref,s=e._owner;if(null!=n){if(void 0!==n.ref&&(l=n.ref,s=O.current),void 0!==n.key&&(i=""+n.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(u in n)j.call(n,u)&&!R.hasOwnProperty(u)&&(r[u]=void 0===n[u]&&void 0!==c?c[u]:n[u])}var u=arguments.length-2;if(1===u)r.children=t;else if(1<u){c=Array(u);for(var p=0;p<u;p++)c[p]=arguments[p+2];r.children=c}return{$$typeof:o,type:e.type,key:i,ref:l,props:r,_owner:s}},createFactory:function(e){var n=q.bind(null,e);return n.type=e,n},isValidElement:T,version:"16.10.2",unstable_withSuspenseConfig:function(e,n){var t=E.suspense;E.suspense=void 0===n?null:n;try{e()}finally{E.suspense=t}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:x,ReactCurrentBatchConfig:E,ReactCurrentOwner:O,IsSomeRendererActing:{current:!1},assign:a}},B={default:Q},F=B&&Q||B;e.exports=F.default||F},7378:function(e,n,t){t(1535)},3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=c(t),f=r,d=h["".concat(s,".").concat(f)]||h[f]||p[f]||o;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},3869:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var a=t(7462),r=t(3366),o=(t(7378),t(3905)),i=["components"],l={title:"Channels",hide_title:!0},s="Using Channels",c={unversionedId:"advanced/Channels",id:"advanced/Channels",isDocsHomePage:!1,title:"Channels",description:"Until now we've used the take and put effects to communicate with the Redux Store. Channels generalize those Effects to communicate with external event sources or between Sagas themselves. They can also be used to queue specific actions from the Store.",source:"@site/../docs/advanced/Channels.md",sourceDirName:"advanced",slug:"/advanced/Channels",permalink:"/docs/advanced/Channels",editUrl:"https://github.com/redux-saga/redux-saga/edit/master/docs/../docs/advanced/Channels.md",tags:[],version:"current",frontMatter:{title:"Channels",hide_title:!0},sidebar:"docs",previous:{title:"Using Saga Helpers",permalink:"/docs/basics/UsingSagaHelpers"},next:{title:"Composing Sagas",permalink:"/docs/advanced/ComposingSagas"}},u=[{value:"Using the <code>actionChannel</code> Effect",id:"using-the-actionchannel-effect",children:[],level:2},{value:"Using the <code>eventChannel</code> factory to connect to external events",id:"using-the-eventchannel-factory-to-connect-to-external-events",children:[{value:"Using channels to communicate between Sagas",id:"using-channels-to-communicate-between-sagas",children:[],level:3}],level:2}],p={toc:u};function h(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"using-channels"},"Using Channels"),(0,o.kt)("p",null,"Until now we've used the ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"put")," effects to communicate with the Redux Store. Channels generalize those Effects to communicate with external event sources or between Sagas themselves. They can also be used to queue specific actions from the Store."),(0,o.kt)("p",null,"In this section, we'll see:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"yield actionChannel")," Effect to buffer specific actions from the Store.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"eventChannel")," factory function to connect ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," Effects to external event sources.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How to create a channel using the generic ",(0,o.kt)("inlineCode",{parentName:"p"},"channel")," factory function and use it in ",(0,o.kt)("inlineCode",{parentName:"p"},"take"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"put")," Effects to communicate between two Sagas."))),(0,o.kt)("h2",{id:"using-the-actionchannel-effect"},"Using the ",(0,o.kt)("inlineCode",{parentName:"h2"},"actionChannel")," Effect"),(0,o.kt)("p",null,"Let's review the canonical example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, fork, ... } from 'redux-saga/effects'\n\nfunction* watchRequests() {\n  while (true) {\n    const {payload} = yield take('REQUEST')\n    yield fork(handleRequest, payload)\n  }\n}\n\nfunction* handleRequest(payload) { ... }\n")),(0,o.kt)("p",null,"The above example illustrates the typical ",(0,o.kt)("em",{parentName:"p"},"watch-and-fork")," pattern. The ",(0,o.kt)("inlineCode",{parentName:"p"},"watchRequests")," saga is using ",(0,o.kt)("inlineCode",{parentName:"p"},"fork")," to avoid blocking and thus not missing any action from the store. A ",(0,o.kt)("inlineCode",{parentName:"p"},"handleRequest")," task is created on each ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," action. So if there are many actions fired at a rapid rate there can be many ",(0,o.kt)("inlineCode",{parentName:"p"},"handleRequest")," tasks executing concurrently."),(0,o.kt)("p",null,"Imagine now that our requirement is as follows: we want to process ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," serially. If we have at any moment four actions, we want to handle the first ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," action, then only after finishing this action we process the second action and so on..."),(0,o.kt)("p",null,"So we want to ",(0,o.kt)("em",{parentName:"p"},"queue")," all non-processed actions, and once we're done with processing the current request, we get the next message from the queue."),(0,o.kt)("p",null,"Redux-Saga provides a little helper Effect ",(0,o.kt)("inlineCode",{parentName:"p"},"actionChannel"),", which can handle this for us. Let's see how we can rewrite the previous example with it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, actionChannel, call, ... } from 'redux-saga/effects'\n\nfunction* watchRequests() {\n  // 1- Create a channel for request actions\n  const requestChan = yield actionChannel('REQUEST')\n  while (true) {\n    // 2- take from the channel\n    const {payload} = yield take(requestChan)\n    // 3- Note that we're using a blocking call\n    yield call(handleRequest, payload)\n  }\n}\n\nfunction* handleRequest(payload) { ... }\n")),(0,o.kt)("p",null,"The first thing is to create the action channel. We use ",(0,o.kt)("inlineCode",{parentName:"p"},"yield actionChannel(pattern)")," where pattern is interpreted using the same rules we mentioned previously with ",(0,o.kt)("inlineCode",{parentName:"p"},"take(pattern)"),". The difference between the 2 forms is that ",(0,o.kt)("inlineCode",{parentName:"p"},"actionChannel")," ",(0,o.kt)("strong",{parentName:"p"},"can buffer incoming messages")," if the Saga is not yet ready to take them (e.g. blocked on an API call)."),(0,o.kt)("p",null,"Next is the ",(0,o.kt)("inlineCode",{parentName:"p"},"yield take(requestChan)"),". Besides usage with a ",(0,o.kt)("inlineCode",{parentName:"p"},"pattern")," to take specific actions from the Redux Store, ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," can also be used with channels (above we created a channel object from specific Redux actions). The ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," will block the Saga until a message is available on the channel. The take may also resume immediately if there is a message stored in the underlying buffer."),(0,o.kt)("p",null,"The important thing to note is how we're using a blocking ",(0,o.kt)("inlineCode",{parentName:"p"},"call"),". The Saga will remain blocked until ",(0,o.kt)("inlineCode",{parentName:"p"},"call(handleRequest)")," returns. But meanwhile, if other ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," actions are dispatched while the Saga is still blocked, they will queued internally by ",(0,o.kt)("inlineCode",{parentName:"p"},"requestChan"),". When the Saga resumes from ",(0,o.kt)("inlineCode",{parentName:"p"},"call(handleRequest)")," and executes the next ",(0,o.kt)("inlineCode",{parentName:"p"},"yield take(requestChan)"),", the take will resolve with the queued message."),(0,o.kt)("p",null,"By default, ",(0,o.kt)("inlineCode",{parentName:"p"},"actionChannel")," buffers all incoming messages without limit. If you want a more control over the buffering, you can supply a Buffer argument to the effect creator. Redux-Saga provides some common buffers (none, dropping, sliding) but you can also supply your own buffer implementation. ",(0,o.kt)("a",{parentName:"p",href:"../api#buffers"},"See API docs")," for more details."),(0,o.kt)("p",null,"For example if you want to handle only the most recent five items you can use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { buffers } from 'redux-saga'\nimport { actionChannel } from 'redux-saga/effects'\n\nfunction* watchRequests() {\n  const requestChan = yield actionChannel('REQUEST', buffers.sliding(5))\n  ...\n}\n")),(0,o.kt)("h2",{id:"using-the-eventchannel-factory-to-connect-to-external-events"},"Using the ",(0,o.kt)("inlineCode",{parentName:"h2"},"eventChannel")," factory to connect to external events"),(0,o.kt)("p",null,"Like ",(0,o.kt)("inlineCode",{parentName:"p"},"actionChannel")," (Effect), ",(0,o.kt)("inlineCode",{parentName:"p"},"eventChannel")," (a factory function, not an Effect) creates a Channel for events but from event sources other than the Redux Store."),(0,o.kt)("p",null,"This basic example creates a Channel from an interval:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { eventChannel, END } from 'redux-saga'\n\nfunction countdown(secs) {\n  return eventChannel(emitter => {\n      const iv = setInterval(() => {\n        secs -= 1\n        if (secs > 0) {\n          emitter(secs)\n        } else {\n          // this causes the channel to close\n          emitter(END)\n        }\n      }, 1000);\n      // The subscriber must return an unsubscribe function\n      return () => {\n        clearInterval(iv)\n      }\n    }\n  )\n}\n")),(0,o.kt)("p",null,"The first argument in ",(0,o.kt)("inlineCode",{parentName:"p"},"eventChannel")," is a ",(0,o.kt)("em",{parentName:"p"},"subscriber")," function. The role of the subscriber is to initialize the external event source (above using ",(0,o.kt)("inlineCode",{parentName:"p"},"setInterval"),"), then routes all incoming events from the source to the channel by invoking the supplied ",(0,o.kt)("inlineCode",{parentName:"p"},"emitter"),". In the above example we're invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"emitter")," on each second."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: You need to sanitize your event sources as to not pass null or undefined through the event channel. While it's fine to pass numbers through, we'd recommend structuring your event channel data like your redux actions. ",(0,o.kt)("inlineCode",{parentName:"p"},"{ number }")," over ",(0,o.kt)("inlineCode",{parentName:"p"},"number"),".")),(0,o.kt)("p",null,"Note also the invocation ",(0,o.kt)("inlineCode",{parentName:"p"},"emitter(END)"),". We use this to notify any channel consumer that the channel has been closed, meaning no other messages will come through this channel."),(0,o.kt)("p",null,"Let's see how we can use this channel from our Saga. (This is taken from the cancellable-counter example in the repo.)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, put, call } from 'redux-saga/effects'\nimport { eventChannel, END } from 'redux-saga'\n\n// creates an event Channel from an interval of seconds\nfunction countdown(seconds) { ... }\n\nexport function* saga() {\n  const chan = yield call(countdown, value)\n  try {    \n    while (true) {\n      // take(END) will cause the saga to terminate by jumping to the finally block\n      let seconds = yield take(chan)\n      console.log(`countdown: ${seconds}`)\n    }\n  } finally {\n    console.log('countdown terminated')\n  }\n}\n")),(0,o.kt)("p",null,"So the Saga is yielding a ",(0,o.kt)("inlineCode",{parentName:"p"},"take(chan)"),". This causes the Saga to block until a message is put on the channel. In our example above, it corresponds to when we invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"emitter(secs)"),". Note also we're executing the whole ",(0,o.kt)("inlineCode",{parentName:"p"},"while (true) {...}")," loop inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"try/finally")," block. When the interval terminates, the countdown function closes the event channel by invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"emitter(END)"),". Closing a channel has the effect of terminating all Sagas blocked on a ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," from that channel. In our example, terminating the Saga will cause it to jump to its ",(0,o.kt)("inlineCode",{parentName:"p"},"finally")," block (if provided, otherwise the Saga terminates)."),(0,o.kt)("p",null,"The subscriber returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"unsubscribe")," function. This is used by the channel to unsubscribe before the event source complete. Inside a Saga consuming messages from an event channel, if we want to ",(0,o.kt)("em",{parentName:"p"},"exit early")," before the event source complete (e.g. Saga has been cancelled) you can call ",(0,o.kt)("inlineCode",{parentName:"p"},"chan.close()")," to close the channel and unsubscribe from the source."),(0,o.kt)("p",null,"For example, we can make our Saga support cancellation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, put, call, cancelled } from 'redux-saga/effects'\nimport { eventChannel, END } from 'redux-saga'\n\n// creates an event Channel from an interval of seconds\nfunction countdown(seconds) { ... }\n\nexport function* saga() {\n  const chan = yield call(countdown, value)\n  try {    \n    while (true) {\n      let seconds = yield take(chan)\n      console.log(`countdown: ${seconds}`)\n    }\n  } finally {\n    if (yield cancelled()) {\n      chan.close()\n      console.log('countdown cancelled')\n    }    \n  }\n}\n")),(0,o.kt)("p",null,"Here is another example of how you can use event channels to pass WebSocket events into your saga (e.g.: using socket.io library).\nSuppose you are waiting for a server message ",(0,o.kt)("inlineCode",{parentName:"p"},"ping")," then reply with a ",(0,o.kt)("inlineCode",{parentName:"p"},"pong")," message after some delay."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, put, call, apply, delay } from 'redux-saga/effects'\nimport { eventChannel } from 'redux-saga'\nimport { createWebSocketConnection } from './socketConnection'\n\n// this function creates an event channel from a given socket\n// Setup subscription to incoming `ping` events\nfunction createSocketChannel(socket) {\n  // `eventChannel` takes a subscriber function\n  // the subscriber function takes an `emit` argument to put messages onto the channel\n  return eventChannel(emit => {\n\n    const pingHandler = (event) => {\n      // puts event payload into the channel\n      // this allows a Saga to take this payload from the returned channel\n      emit(event.payload)\n    }\n    \n    const errorHandler = (errorEvent) => {\n      // create an Error object and put it into the channel\n      emit(new Error(errorEvent.reason))\n    }\n    \n    // setup the subscription\n    socket.on('ping', pingHandler)\n    socket.on('error', errorHandler)\n\n    // the subscriber must return an unsubscribe function\n    // this will be invoked when the saga calls `channel.close` method\n    const unsubscribe = () => {\n      socket.off('ping', pingHandler)\n    }\n\n    return unsubscribe\n  })\n}\n\n// reply with a `pong` message by invoking `socket.emit('pong')`\nfunction* pong(socket) {\n  yield delay(5000)\n  yield apply(socket, socket.emit, ['pong']) // call `emit` as a method with `socket` as context\n}\n\nexport function* watchOnPings() {\n  const socket = yield call(createWebSocketConnection)\n  const socketChannel = yield call(createSocketChannel, socket)\n\n  while (true) {\n    try {\n      // An error from socketChannel will cause the saga jump to the catch block\n      const payload = yield take(socketChannel)\n      yield put({ type: INCOMING_PONG_PAYLOAD, payload })\n      yield fork(pong, socket)\n    } catch(err) {\n      console.error('socket error:', err)\n      // socketChannel is still open in catch block\n      // if we want end the socketChannel, we need close it explicitly\n      // socketChannel.close()\n    }\n  }\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: messages on an eventChannel are not buffered by default. You have to provide a buffer to the eventChannel factory in order to specify buffering strategy for the channel (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"eventChannel(subscriber, buffer)"),").\n",(0,o.kt)("a",{parentName:"p",href:"../api#buffers"},"See the API docs")," for more info.")),(0,o.kt)("p",null,"In this WebSocket example, the socketChannel may emit an error when some socket error occurs, this will abort our ",(0,o.kt)("inlineCode",{parentName:"p"},"yield take(socketChannel)")," waiting on this eventChannel. Note that emitting an error will not abort the channel by default, we need to close the channel explicitly if we want to end the channel after an error."),(0,o.kt)("h3",{id:"using-channels-to-communicate-between-sagas"},"Using channels to communicate between Sagas"),(0,o.kt)("p",null,"Besides action channels and event channels, You can also directly create channels which are not connected to any source by default. You can then manually ",(0,o.kt)("inlineCode",{parentName:"p"},"put")," on the channel. This is handy when you want to use a channel to communicate between sagas."),(0,o.kt)("p",null,"To illustrate, let's review the former example of request handling."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { take, fork, ... } from 'redux-saga/effects'\n\nfunction* watchRequests() {\n  while (true) {\n    const {payload} = yield take('REQUEST')\n    yield fork(handleRequest, payload)\n  }\n}\n\nfunction* handleRequest(payload) { ... }\n")),(0,o.kt)("p",null,"We saw that the watch-and-fork pattern allows handling multiple requests simultaneously, without limit on the number of worker tasks executing concurrently. Then, we used the ",(0,o.kt)("inlineCode",{parentName:"p"},"actionChannel")," effect to limit the concurrency to one task at a time."),(0,o.kt)("p",null,"So let's say that our requirement is to have a maximum of three tasks executing at the same time. When we get a request and there are less than three tasks executing, we process the request immediately, otherwise we queue the task and wait for one of the three ",(0,o.kt)("em",{parentName:"p"},"slots")," to become free."),(0,o.kt)("p",null,"Below is an example of a solution using channels:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { channel } from 'redux-saga'\nimport { take, fork, ... } from 'redux-saga/effects'\n\nfunction* watchRequests() {\n  // create a channel to queue incoming requests\n  const chan = yield call(channel)\n\n  // create 3 worker 'threads'\n  for (var i = 0; i < 3; i++) {\n    yield fork(handleRequest, chan)\n  }\n\n  while (true) {\n    const {payload} = yield take('REQUEST')\n    yield put(chan, payload)\n  }\n}\n\nfunction* handleRequest(chan) {\n  while (true) {\n    const payload = yield take(chan)\n    // process the request\n  }\n}\n")),(0,o.kt)("p",null,"In the above example, we create a channel using the ",(0,o.kt)("inlineCode",{parentName:"p"},"channel")," factory. We get back a channel which by default buffers all messages we put on it (unless there is a pending taker, in which the taker is resumed immediately with the message)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"watchRequests")," saga then forks three worker sagas. Note the created channel is supplied to all forked sagas. ",(0,o.kt)("inlineCode",{parentName:"p"},"watchRequests")," will use this channel to ",(0,o.kt)("em",{parentName:"p"},"dispatch")," work to the three worker sagas. On each ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," action the Saga will put the payload on the channel. The payload will then be taken by any ",(0,o.kt)("em",{parentName:"p"},"free")," worker. Otherwise it will be queued by the channel until a worker Saga is ready to take it."),(0,o.kt)("p",null,"All the three workers run a typical while loop. On each iteration, a worker will take the next request, or will block until a message is available. Note that this mechanism provides an automatic load-balancing between the 3 workers. Rapid workers are not slowed down by slow workers."))}h.isMDXComponent=!0}}]);